{"code":"import * as ts from 'typescript';\r\nimport * as Beautify from 'js-beautify';\r\nvar _namespace = 'MyNamespace';\r\nexport var setNamespace = function (name) { return (_namespace = name); };\r\nexport function createProgram(files, compilerOptions) {\r\n    var tsConfigJson = ts.parseConfigFileTextToJson('tsconfig.json', compilerOptions\r\n        ? JSON.stringify(compilerOptions)\r\n        : \"{\\n      \\\"compilerOptions\\\": {\\n        \\\"target\\\": \\\"es2018\\\",   \\n        \\\"module\\\": \\\"commonjs\\\", \\n        \\\"lib\\\": [\\\"es2018\\\"],\\n        \\\"rootDir\\\": \\\".\\\",\\n        \\\"strict\\\": false,   \\n        \\\"esModuleInterop\\\": true,\\n        \\\"noImplicitAny\\\": true,\\n        \\\"allowJs\\\": true\\n      }\\n    \");\r\n    var _a = ts.convertCompilerOptionsFromJson(tsConfigJson.config.compilerOptions, '.'), options = _a.options, errors = _a.errors;\r\n    if (errors.length) {\r\n        throw errors;\r\n    }\r\n    var compilerHost = ts.createCompilerHost(options);\r\n    compilerHost.getSourceFile = function (fileName, languageVersion, onError, shouldCreateNewSourceFile) {\r\n        var file = files.find(function (f) { return f.fileName === fileName; });\r\n        if (!file)\r\n            return undefined;\r\n        file.sourceFile =\r\n            file.sourceFile || ts.createSourceFile(fileName, file.content, ts.ScriptTarget.ES2015, true);\r\n        return file.sourceFile;\r\n    };\r\n    // in order to typechecker to work we need to implement the following method, the following implementation is enough:\r\n    compilerHost.resolveTypeReferenceDirectives = function (typeReferenceDirectiveNames, containingFile) {\r\n        return [];\r\n    };\r\n    return ts.createProgram(files.map(function (f) { return f.fileName; }), options, compilerHost);\r\n}\r\n// ---------------\r\nvar EQUAL_TOKEN = 59;\r\nvar THIS_TOKEN = 100;\r\nexport function collectProperties(program) {\r\n    var properties = [];\r\n    var localVariables = [];\r\n    var checker = program.getTypeChecker();\r\n    function visit(node, parentSymbol, fromStatic) {\r\n        if (parentSymbol === void 0) { parentSymbol = null; }\r\n        if (fromStatic === void 0) { fromStatic = null; }\r\n        if (ts.isVariableStatement(node)) {\r\n            for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {\r\n                var declaration = _a[_i];\r\n                if (ts.isIdentifier(declaration.name))\r\n                    localVariables.push(declaration.name.escapedText.toString());\r\n            }\r\n        }\r\n        else if (ts.isFunctionDeclaration(node)) {\r\n            var name = node.name.escapedText.toString();\r\n            var statements = node.body.statements;\r\n            for (var _b = 0, statements_1 = statements; _b < statements_1.length; _b++) {\r\n                var statement = statements_1[_b];\r\n                visit(statement, name, false);\r\n            }\r\n        }\r\n        else if (ts.isExpressionStatement(node) &&\r\n            ts.isBinaryExpression(node.expression) &&\r\n            node.expression.operatorToken.kind === EQUAL_TOKEN) {\r\n            if (ts.isPropertyAccessExpression(node.expression.left)) {\r\n                var expr = node.expression.left;\r\n                var symbol = void 0, name = void 0, type = void 0, _static = void 0;\r\n                if (expr.expression.kind === THIS_TOKEN) {\r\n                    // this.a = 10\r\n                    symbol = parentSymbol;\r\n                    _static = fromStatic;\r\n                    name = expr.name.escapedText.toString();\r\n                    type = getTypeString(checker, node.expression.right);\r\n                }\r\n                else if (ts.isIdentifier(expr.expression)) {\r\n                    // Global.a = 10\r\n                    symbol = expr.expression.escapedText.toString();\r\n                    _static = true;\r\n                    name = expr.name.escapedText.toString();\r\n                    type = getTypeString(checker, node.expression.right);\r\n                }\r\n                else if (ts.isPropertyAccessExpression(expr.expression) &&\r\n                    expr.expression.name.kind === 72 /* prototype */ &&\r\n                    ts.isIdentifier(expr.expression.expression)) {\r\n                    // Global.prototype.a = 10\r\n                    symbol = expr.expression.expression.escapedText.toString();\r\n                    name = expr.name.escapedText.toString();\r\n                    type = getTypeString(checker, node.expression.right);\r\n                    _static = false;\r\n                }\r\n                // Found\r\n                if (symbol) {\r\n                    var doc = void 0;\r\n                    if (node.jsDoc) {\r\n                        doc = node.jsDoc[node.jsDoc.length - 1];\r\n                        type = extractJsDocType(doc);\r\n                    }\r\n                    var property_1 = {\r\n                        name: name,\r\n                        parentSymbol: symbol,\r\n                        static: _static,\r\n                        type: type,\r\n                        jsDoc: doc\r\n                    };\r\n                    var exist = properties.find(function (p) {\r\n                        return p.name === property_1.name &&\r\n                            p.parentSymbol === property_1.parentSymbol &&\r\n                            p.static === property_1.static;\r\n                    });\r\n                    var forbidden = ['constructor', 'prototype'];\r\n                    var localCheck = expr.expression.kind === THIS_TOKEN\r\n                        ? true\r\n                        : !localVariables.includes(name) && !localVariables.includes(symbol);\r\n                    if (!exist && !forbidden.includes(name) && localCheck) {\r\n                        properties.push(property_1);\r\n                        if (ts.isFunctionExpression(node.expression.right)) {\r\n                            var statements = node.expression.right.body.statements;\r\n                            for (var _c = 0, statements_2 = statements; _c < statements_2.length; _c++) {\r\n                                var statement = statements_2[_c];\r\n                                visit(statement, symbol, _static);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    traverseProgram(program, visit);\r\n    return properties;\r\n}\r\nexport function makePseudoClasses(program, properties) {\r\n    var classes = [];\r\n    var checker = program.getTypeChecker();\r\n    function visit(node) {\r\n        if (ts.isFunctionDeclaration(node)) {\r\n            var name_1 = node.name.escapedText.toString();\r\n            var constructorArgs = makeVariablesFromParameters(checker, Array.from(node.parameters || []));\r\n            var jsDoc = node.jsDoc;\r\n            var lastJsDoc = jsDoc ? jsDoc[jsDoc.length - 1] : null;\r\n            // - Look for call of the true constructor\r\n            var constructorProperty = null;\r\n            for (var _i = 0, _a = node.body.statements; _i < _a.length; _i++) {\r\n                var statement = _a[_i];\r\n                if (ts.isExpressionStatement(statement)) {\r\n                    var str = statement.getText();\r\n                    if (str.match(/this\\.(.+)\\.apply\\(this,/i)) {\r\n                        constructorProperty = properties.find(function (p) { return p.parentSymbol === name_1 && p.name === RegExp.$1; });\r\n                        if (jsDoc)\r\n                            constructorProperty.type = extractJsDocType(lastJsDoc, constructorProperty.type);\r\n                    }\r\n                }\r\n            }\r\n            var constructorSignature = null;\r\n            if (!constructorProperty) {\r\n                constructorSignature = jsDoc\r\n                    ? extractJsDocType(lastJsDoc).replace(/\\=\\>.+/i, '')\r\n                    : \"(\" + constructorArgs.map(function (p) { return p.name + \": \" + p.type; }).join(', ') + \")\";\r\n            }\r\n            classes.push({\r\n                name: name_1,\r\n                constructorArgs: constructorArgs,\r\n                properties: properties.map(function (p) { return (p.parentSymbol === name_1 ? p : null); }).filter(function (v) { return !!v; }),\r\n                constructorProperty: constructorProperty,\r\n                jsDoc: jsDoc ? lastJsDoc : null,\r\n                constructorSignature: constructorSignature\r\n            });\r\n        }\r\n        else if (ts.isExpressionStatement(node)) {\r\n            var str = node.getText();\r\n            if (str.match(/(.+)\\.prototype\\s*\\=\\s*Object\\.create\\((.+)\\.prototype\\)/i)) {\r\n                // -\r\n                var _class = classes.find(function (c) { return c.name === RegExp.$1; });\r\n                if (!_class) {\r\n                    _class = {\r\n                        constructorArgs: [],\r\n                        global: true,\r\n                        name: RegExp.$1,\r\n                        properties: [],\r\n                        extends: RegExp.$2\r\n                    };\r\n                    classes.push(_class);\r\n                }\r\n                else {\r\n                    _class.extends = RegExp.$2;\r\n                }\r\n            }\r\n            else if (str.match(/Object\\.definePropert.+\\((.+?),/i) && ts.isCallExpression(node.expression)) {\r\n                // - Extract properties from getter/setter\r\n                var properties_2 = [];\r\n                var value = RegExp.$1;\r\n                var symbol_1, _static = void 0;\r\n                if (value.match(/(.+)\\.prototype/)) {\r\n                    symbol_1 = RegExp.$1;\r\n                    _static = false;\r\n                }\r\n                else {\r\n                    symbol_1 = value;\r\n                    _static = true;\r\n                }\r\n                var arg = node.expression.arguments[1];\r\n                if (ts.isStringLiteral(arg)) {\r\n                    var jsDoc = node.jsDoc || null;\r\n                    var lastJsDoc = jsDoc ? jsDoc[jsDoc.length - 1] : null;\r\n                    var objArg = node.expression.arguments[2];\r\n                    if (ts.isObjectLiteralExpression(objArg)) {\r\n                        var result = makePropertyFromObjectLiteral(checker, objArg, lastJsDoc);\r\n                        properties_2.push({\r\n                            name: arg.text,\r\n                            parentSymbol: symbol_1,\r\n                            static: _static,\r\n                            type: result.type,\r\n                            readonly: result.readonly\r\n                        });\r\n                    }\r\n                }\r\n                else if (ts.isObjectLiteralExpression(arg)) {\r\n                    for (var _b = 0, _c = arg.properties; _b < _c.length; _b++) {\r\n                        var prop = _c[_b];\r\n                        if (ts.isPropertyAssignment(prop)) {\r\n                            var jsDoc = prop.jsDoc || null;\r\n                            var lastJsDoc = jsDoc ? jsDoc[jsDoc.length - 1] : null;\r\n                            var name = prop.name.escapedText.toString();\r\n                            if (ts.isObjectLiteralExpression(prop.initializer)) {\r\n                                var result = makePropertyFromObjectLiteral(checker, prop.initializer, lastJsDoc);\r\n                                properties_2.push({\r\n                                    name: name,\r\n                                    parentSymbol: symbol_1,\r\n                                    readonly: result.readonly,\r\n                                    static: _static,\r\n                                    type: result.type,\r\n                                    jsDoc: jsDoc\r\n                                });\r\n                            }\r\n                            else {\r\n                                properties_2.push({\r\n                                    name: name,\r\n                                    parentSymbol: symbol_1,\r\n                                    readonly: true,\r\n                                    static: _static,\r\n                                    type: getTypeString(checker, prop.initializer),\r\n                                    jsDoc: jsDoc\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                var _class = classes.find(function (c) { return c.name === symbol_1; });\r\n                if (!_class) {\r\n                    _class = {\r\n                        constructorArgs: [],\r\n                        global: true,\r\n                        name: symbol_1,\r\n                        properties: properties_2.slice()\r\n                    };\r\n                    classes.push(_class);\r\n                }\r\n                else {\r\n                    _class.properties = [].concat(_class.properties, properties_2);\r\n                }\r\n            }\r\n        }\r\n        //ts.forEachChild(node, visit);\r\n    }\r\n    traverseProgram(program, visit);\r\n    var _loop_1 = function (p) {\r\n        var _class = classes.find(function (c) { return c.name === p.parentSymbol; });\r\n        if (!_class) {\r\n            classes.push({\r\n                constructorArgs: [],\r\n                constructorProperty: null,\r\n                global: true,\r\n                name: p.parentSymbol,\r\n                properties: properties\r\n                    .map(function (_p) { return (_p.parentSymbol === p.parentSymbol ? _p : null); })\r\n                    .filter(function (v) { return !!v; })\r\n            });\r\n        }\r\n    };\r\n    // - Find out global pseudo classes\r\n    for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {\r\n        var p = properties_1[_i];\r\n        _loop_1(p);\r\n    }\r\n    return classes;\r\n}\r\nexport function makePropertyFromObjectLiteral(checker, expr, jsDoc) {\r\n    var readonly = true;\r\n    var type = 'any';\r\n    for (var _i = 0, _a = expr.properties; _i < _a.length; _i++) {\r\n        var prop = _a[_i];\r\n        if (ts.isPropertyAssignment(prop)) {\r\n            if (prop.name.escapedText.toString() === 'set') {\r\n                readonly = false;\r\n            }\r\n            else if (prop.name.escapedText.toString() === 'get') {\r\n                type = getTypeString(checker, prop.initializer);\r\n                if (type.match(/\\=\\>(.+)/i)) {\r\n                    type = RegExp.$1.trim();\r\n                }\r\n                if (jsDoc) {\r\n                    type = extractJsDocType(jsDoc, type);\r\n                }\r\n            }\r\n            else if (prop.name.escapedText.toString() === 'value') {\r\n                type = getTypeString(checker, prop.initializer);\r\n                if (jsDoc) {\r\n                    type = extractJsDocType(jsDoc, type);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        readonly: readonly,\r\n        type: type\r\n    };\r\n}\r\nexport function makeVariablesFromParameters(checker, params) {\r\n    var variables = [];\r\n    for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {\r\n        var param = params_1[_i];\r\n        variables.push({\r\n            name: param.name.escapedText.toString(),\r\n            type: getTypeString(checker, param)\r\n        });\r\n    }\r\n    return variables;\r\n}\r\nexport function traverseProgram(program, callback) {\r\n    for (var _i = 0, _a = program.getSourceFiles(); _i < _a.length; _i++) {\r\n        var sourceFile = _a[_i];\r\n        if (!sourceFile.isDeclarationFile) {\r\n            // Walk the tree to search for classes\r\n            ts.forEachChild(sourceFile, callback);\r\n        }\r\n    }\r\n}\r\nexport function getTypeString(checker, node) {\r\n    var type = checker.getTypeAtLocation(node);\r\n    if (node.getText().match(/^\\s*new\\s+(.+?)\\(.*\\)/i)) {\r\n        return RegExp.$1.trim();\r\n    }\r\n    if (type.isLiteral()) {\r\n        type = checker.getBaseTypeOfLiteralType(type);\r\n    }\r\n    var value = checker.typeToString(type, node, ts.TypeFormatFlags.NoTruncation);\r\n    if (value === 'null')\r\n        return 'any';\r\n    if (value === 'false' || value === 'true')\r\n        return 'boolean';\r\n    return value;\r\n}\r\nexport function convertJsDocType(type) {\r\n    if (type.includes('|')) {\r\n        return type\r\n            .split('|')\r\n            .map(function (v) { return convertJsDocType(v); })\r\n            .join(' | ');\r\n    }\r\n    type =\r\n        {\r\n            String: 'string',\r\n            Number: 'number',\r\n            Array: 'any[]',\r\n            Any: 'any',\r\n            Boolean: 'boolean',\r\n            '*': 'any'\r\n        }[type] || type;\r\n    return type;\r\n}\r\nexport function extractJsDocType(doc, currentType) {\r\n    if (currentType === void 0) { currentType = ''; }\r\n    var params = [];\r\n    var returnType = 'any';\r\n    var absoluteType;\r\n    var extractType = function (tag) {\r\n        var type;\r\n        if (tag.typeExpression == null) {\r\n            type = 'any';\r\n        }\r\n        else {\r\n            type = tag.typeExpression.type.getText();\r\n            // if (!(tag.typeExpression.type as any).typeName) {\r\n            //   type = tag.typeExpression.type.getText();\r\n            // } else {\r\n            //   type = (tag.typeExpression.type as any).typeName.escapedText.toString();\r\n            // }\r\n        }\r\n        return type;\r\n    };\r\n    var autoGeneratedArgs = 0;\r\n    for (var _i = 0, _a = Array.from(doc.tags || []); _i < _a.length; _i++) {\r\n        var tag = _a[_i];\r\n        if (ts.isJSDocTypeTag(tag)) {\r\n            absoluteType = extractType(tag);\r\n            return convertJsDocType(absoluteType);\r\n        }\r\n        else if (ts.isJSDocParameterTag(tag)) {\r\n            var type = extractType(tag);\r\n            var name = tag.name.escapedText.toString();\r\n            if (!name) {\r\n                var commentArg = tag.comment.split(' ')[0];\r\n                if (commentArg.startsWith('...')) {\r\n                    name = commentArg;\r\n                }\r\n                else {\r\n                    name = \"arg\" + Number(autoGeneratedArgs++);\r\n                }\r\n            }\r\n            params.push({ name: name, type: convertJsDocType(type) });\r\n        }\r\n        else if (ts.isJSDocReturnTag(tag)) {\r\n            var type = extractType(tag);\r\n            returnType = convertJsDocType(type);\r\n        }\r\n    }\r\n    if (currentType.match(/\\(.+\\)\\s*\\=\\>\\s*(.+)/)) {\r\n        returnType = returnType || RegExp.$2.trim();\r\n    }\r\n    return \"(\" + params.map(function (p) { return p.name + \": \" + p.type; }).join(', ') + \") => \" + returnType;\r\n}\r\nexport function makeDTS(classes) {\r\n    var globals = classes.map(function (c) { return (c.global ? c : null); }).filter(function (v) { return !!v; });\r\n    var text = '';\r\n    if (globals.length > 0) {\r\n        text = \"declare global {\\n      \" + globals\r\n            .map(function (c) { return \"interface \" + c.name + \" {\\n        \" + c.properties.map(function (p) { return propertyToString(p).replace('static', ''); }).join('\\n') + \"\\n      }\"; })\r\n            .join('\\n') + \"\\n  }\\n  \";\r\n    }\r\n    var normal = classes.filter(function (c) { return !c.global; });\r\n    text += \"export declare namespace \" + _namespace + \"{\\n    \" + normal.map(function (c) { return classToString(c); }).join('\\n') + \"\\n  }\";\r\n    return Beautify.js(text, {});\r\n}\r\nexport function propertyToString(property) {\r\n    return (\"\" + (property.jsDoc && property.jsDoc.getText ? property.jsDoc.getText() + '\\n' : '') + (property.static ? 'static ' : '') + (property.readonly ? 'readonly ' : '') + property.name + \": \" + property.type + \";\").trim();\r\n}\r\nexport function classToString(_class) {\r\n    var constructorDoc = _class.jsDoc && _class.jsDoc.getText ? _class.jsDoc.getText() : '';\r\n    return \"class \" + _class.name + (_class.extends ? \" extends \" + _class.extends : '') + \" {\" + constructorDoc + \"\\n    \" + (_class.constructorProperty\r\n        ? \"new \" + _class.constructorProperty.type.replace(/ \\=\\>.+/i, '') + \";\\n\"\r\n        : \"new \" + _class.constructorSignature + \";\\n\") + _class.properties\r\n        .filter(function (p) { return p !== _class.constructorProperty; })\r\n        .map(function (p) { return propertyToString(p); })\r\n        .join('\\n\\n') + \"\\n  }\";\r\n}\r\n","dts":{"name":"/media/cyriac/0CC5166B0CC5166B/Work/es5-to-dts/generator.d.ts","writeByteOrderMark":false,"text":"import * as ts from 'typescript';\r\nexport declare const setNamespace: (name: string) => string;\r\nexport interface File {\r\n    fileName: string;\r\n    content: string;\r\n    sourceFile?: ts.SourceFile;\r\n}\r\nexport declare function createProgram(files: File[], compilerOptions?: ts.CompilerOptions): ts.Program;\r\nexport interface Variable {\r\n    name: string;\r\n    type: string;\r\n}\r\nexport interface Property {\r\n    parentSymbol: string;\r\n    name: string;\r\n    type: string;\r\n    static?: boolean;\r\n    readonly?: boolean;\r\n    jsDoc?: ts.JSDoc;\r\n}\r\nexport declare function collectProperties(program: ts.Program): Property[];\r\ninterface PseudoClass {\r\n    name: string;\r\n    constructorArgs: Variable[];\r\n    properties: Property[];\r\n    global?: boolean;\r\n    constructorProperty?: Property;\r\n    constructorSignature?: string;\r\n    extends?: string;\r\n    jsDoc?: ts.JSDoc;\r\n}\r\nexport declare function makePseudoClasses(program: ts.Program, properties: Property[]): PseudoClass[];\r\nexport declare function makePropertyFromObjectLiteral(checker: ts.TypeChecker, expr: ts.ObjectLiteralExpression, jsDoc: ts.JSDoc): {\r\n    readonly: boolean;\r\n    type: string;\r\n};\r\nexport declare function makeVariablesFromParameters(checker: ts.TypeChecker, params: ts.ParameterDeclaration[]): Variable[];\r\nexport declare function traverseProgram(program: ts.Program, callback: (node: ts.Node) => any): void;\r\nexport declare function getTypeString(checker: ts.TypeChecker, node: ts.Node): string;\r\nexport declare function convertJsDocType(type: string): any;\r\nexport declare function extractJsDocType(doc: ts.JSDoc, currentType?: string): any;\r\nexport declare function makeDTS(classes: PseudoClass[]): any;\r\nexport declare function propertyToString(property: Property): string;\r\nexport declare function classToString(_class: PseudoClass): string;\r\nexport {};\r\n"}}
