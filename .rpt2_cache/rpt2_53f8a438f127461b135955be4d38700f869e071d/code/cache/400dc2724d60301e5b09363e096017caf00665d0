{"code":"import * as ts from 'typescript';\r\nimport * as Beautify from 'js-beautify';\r\nexport function createProgram(files, compilerOptions) {\r\n    var tsConfigJson = ts.parseConfigFileTextToJson('tsconfig.json', compilerOptions\r\n        ? JSON.stringify(compilerOptions)\r\n        : \"{\\n      \\\"compilerOptions\\\": {\\n        \\\"target\\\": \\\"es2018\\\",   \\n        \\\"module\\\": \\\"commonjs\\\", \\n        \\\"lib\\\": [\\\"es2018\\\"],\\n        \\\"rootDir\\\": \\\".\\\",\\n        \\\"strict\\\": false,   \\n        \\\"esModuleInterop\\\": true,\\n        \\\"noImplicitAny\\\": true,\\n        \\\"allowJs\\\": true\\n      }\\n    \");\r\n    var _a = ts.convertCompilerOptionsFromJson(tsConfigJson.config.compilerOptions, '.'), options = _a.options, errors = _a.errors;\r\n    if (errors.length) {\r\n        throw errors;\r\n    }\r\n    var compilerHost = ts.createCompilerHost(options);\r\n    compilerHost.getSourceFile = function (fileName, languageVersion, onError, shouldCreateNewSourceFile) {\r\n        var file = files.find(function (f) { return f.fileName === fileName; });\r\n        if (!file)\r\n            return undefined;\r\n        file.sourceFile =\r\n            file.sourceFile || ts.createSourceFile(fileName, file.content, ts.ScriptTarget.ES2015, true);\r\n        return file.sourceFile;\r\n    };\r\n    // in order to typechecker to work we need to implement the following method, the following implementation is enough:\r\n    compilerHost.resolveTypeReferenceDirectives = function (typeReferenceDirectiveNames, containingFile) {\r\n        return [];\r\n    };\r\n    return ts.createProgram(files.map(function (f) { return f.fileName; }), options, compilerHost);\r\n}\r\n// ---------------\r\nvar EQUAL_TOKEN = 59;\r\nvar THIS_TOKEN = 100;\r\nexport function collectProperties(program) {\r\n    var properties = [];\r\n    var checker = program.getTypeChecker();\r\n    function visit(node, parentSymbol, fromStatic) {\r\n        if (parentSymbol === void 0) { parentSymbol = null; }\r\n        if (fromStatic === void 0) { fromStatic = null; }\r\n        if (ts.isFunctionDeclaration(node)) {\r\n            var name = node.name.escapedText.toString();\r\n            var statements = node.body.statements;\r\n            for (var _i = 0, statements_1 = statements; _i < statements_1.length; _i++) {\r\n                var statement = statements_1[_i];\r\n                visit(statement, name, false);\r\n            }\r\n        }\r\n        else if (ts.isExpressionStatement(node) &&\r\n            ts.isBinaryExpression(node.expression) &&\r\n            node.expression.operatorToken.kind === EQUAL_TOKEN) {\r\n            if (ts.isPropertyAccessExpression(node.expression.left)) {\r\n                var expr = node.expression.left;\r\n                var symbol = void 0, name = void 0, type = void 0, _static = void 0;\r\n                if (expr.expression.kind === THIS_TOKEN) {\r\n                    // this.a = 10\r\n                    symbol = parentSymbol;\r\n                    _static = fromStatic;\r\n                    name = expr.name.escapedText.toString();\r\n                    type = getTypeString(checker, node.expression.right);\r\n                }\r\n                else if (ts.isIdentifier(expr.expression)) {\r\n                    // Global.a = 10\r\n                    symbol = expr.expression.escapedText.toString();\r\n                    _static = true;\r\n                    name = expr.name.escapedText.toString();\r\n                    type = getTypeString(checker, node.expression.right);\r\n                }\r\n                else if (ts.isPropertyAccessExpression(expr.expression) &&\r\n                    expr.expression.name.kind === 72 /* prototype */) {\r\n                    // Global.prototype.a = 10\r\n                    symbol = expr.expression.expression.escapedText.toString();\r\n                    name = expr.name.escapedText.toString();\r\n                    type = getTypeString(checker, node.expression.right);\r\n                    _static = false;\r\n                }\r\n                // Found\r\n                if (symbol) {\r\n                    var property_1 = {\r\n                        name: name,\r\n                        parentSymbol: symbol,\r\n                        static: _static,\r\n                        type: type\r\n                    };\r\n                    var exist = properties.find(function (p) {\r\n                        return p.name === property_1.name &&\r\n                            p.parentSymbol === property_1.parentSymbol &&\r\n                            p.static === property_1.static;\r\n                    });\r\n                    var forbidden = ['constructor', 'prototype'];\r\n                    if (!exist && !forbidden.includes(name)) {\r\n                        properties.push(property_1);\r\n                        if (ts.isFunctionExpression(node.expression.right)) {\r\n                            var statements = node.expression.right.body.statements;\r\n                            for (var _a = 0, statements_2 = statements; _a < statements_2.length; _a++) {\r\n                                var statement = statements_2[_a];\r\n                                visit(statement, symbol, _static);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    traverseProgram(program, visit);\r\n    return properties;\r\n}\r\nexport function makePseudoClasses(program, properties) {\r\n    var classes = [];\r\n    var checker = program.getTypeChecker();\r\n    function visit(node) {\r\n        if (ts.isFunctionDeclaration(node)) {\r\n            var name_1 = node.name.escapedText.toString();\r\n            var constructorArgs = makeVariablesFromParameters(checker, Array.from(node.parameters || []));\r\n            // - Look for call of the true constructor\r\n            var constructorProperty = null;\r\n            for (var _i = 0, _a = node.body.statements; _i < _a.length; _i++) {\r\n                var statement = _a[_i];\r\n                if (ts.isExpressionStatement(statement)) {\r\n                    var str = statement.getText();\r\n                    if (str.match(/this\\.(.+)\\.apply\\(this,/i)) {\r\n                        constructorProperty = properties.find(function (p) { return p.parentSymbol === name_1 && p.name === RegExp.$1; });\r\n                    }\r\n                }\r\n            }\r\n            classes.push({\r\n                name: name_1,\r\n                constructorArgs: constructorArgs,\r\n                properties: properties.map(function (p) { return (p.parentSymbol === name_1 ? p : null); }).filter(function (v) { return !!v; }),\r\n                constructorProperty: constructorProperty\r\n            });\r\n        }\r\n        else if (ts.isExpressionStatement(node)) {\r\n            var str = node.getText();\r\n            if (str.match(/(.+)\\.prototype\\s*\\=\\s*Object\\.create\\((.+)\\.prototype\\)/i)) {\r\n                // -\r\n                var _class = classes.find(function (c) { return c.name === RegExp.$1; });\r\n                _class.extends = RegExp.$2;\r\n            }\r\n            else if (str.match(/Object\\.defineProperties\\((.+)/i)) {\r\n                // - Extract properties from getter/setter\r\n                var value = RegExp.$1;\r\n                var symbol_1, _static = void 0;\r\n                if (value.match(/(.+)\\.prototype/)) {\r\n                    symbol_1 = RegExp.$1;\r\n                    _static = false;\r\n                }\r\n                else {\r\n                    symbol_1 = value;\r\n                    _static = true;\r\n                }\r\n                var arg = node.expression.arguments[1];\r\n                if (ts.isObjectLiteralExpression(arg)) {\r\n                    var properties_2 = [];\r\n                    for (var _b = 0, _c = arg.properties; _b < _c.length; _b++) {\r\n                        var prop = _c[_b];\r\n                        if (ts.isPropertyAssignment(prop)) {\r\n                            var name = prop.name.escapedText.toString();\r\n                            var readonly = true;\r\n                            var type = null;\r\n                            if (ts.isObjectLiteralExpression(prop.initializer)) {\r\n                                for (var _d = 0, _e = prop.initializer.properties; _d < _e.length; _d++) {\r\n                                    var subProp = _e[_d];\r\n                                    if (ts.isPropertyAssignment(subProp)) {\r\n                                        if (subProp.name.escapedText.toString() === 'set') {\r\n                                            readonly = false;\r\n                                        }\r\n                                        else if (subProp.name.escapedText.toString() === 'get') {\r\n                                            type = getTypeString(checker, subProp.initializer);\r\n                                            if (type.match(/\\=\\>(.+)/i)) {\r\n                                                type = RegExp.$1.trim();\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            properties_2.push({\r\n                                name: name,\r\n                                parentSymbol: symbol_1,\r\n                                readonly: readonly,\r\n                                static: _static,\r\n                                type: type\r\n                            });\r\n                        }\r\n                    }\r\n                    var _class = classes.find(function (c) { return c.name === symbol_1; });\r\n                    _class.properties = [].concat(_class.properties, properties_2);\r\n                }\r\n            }\r\n        }\r\n        //ts.forEachChild(node, visit);\r\n    }\r\n    traverseProgram(program, visit);\r\n    var _loop_1 = function (p) {\r\n        var _class = classes.find(function (c) { return c.name === p.parentSymbol; });\r\n        if (!_class) {\r\n            classes.push({\r\n                constructorArgs: [],\r\n                constructorProperty: null,\r\n                global: true,\r\n                name: p.parentSymbol,\r\n                properties: properties\r\n                    .map(function (_p) { return (_p.parentSymbol === p.parentSymbol ? _p : null); })\r\n                    .filter(function (v) { return !!v; })\r\n            });\r\n        }\r\n    };\r\n    // - Find out global pseudo classes\r\n    for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {\r\n        var p = properties_1[_i];\r\n        _loop_1(p);\r\n    }\r\n    return classes;\r\n}\r\nexport function makeVariablesFromParameters(checker, params) {\r\n    var variables = [];\r\n    for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {\r\n        var param = params_1[_i];\r\n        variables.push({\r\n            name: param.name.escapedText.toString(),\r\n            type: getTypeString(checker, param)\r\n        });\r\n    }\r\n    return variables;\r\n}\r\nexport function traverseProgram(program, callback) {\r\n    for (var _i = 0, _a = program.getSourceFiles(); _i < _a.length; _i++) {\r\n        var sourceFile = _a[_i];\r\n        if (!sourceFile.isDeclarationFile) {\r\n            // Walk the tree to search for classes\r\n            ts.forEachChild(sourceFile, callback);\r\n        }\r\n    }\r\n}\r\nexport function getTypeString(checker, node) {\r\n    var type = checker.getTypeAtLocation(node);\r\n    if (type.isLiteral()) {\r\n        type = checker.getBaseTypeOfLiteralType(type);\r\n    }\r\n    return checker.typeToString(type);\r\n}\r\nexport function makeDTS(classes, namespace) {\r\n    var globals = classes.map(function (c) { return (c.global ? c : null); }).filter(function (v) { return !!v; });\r\n    var text = '';\r\n    if (globals.length > 0) {\r\n        text = \"declare global {\\n      \" + globals\r\n            .map(function (c) { return \"interface \" + c.name + \" {\\n        \" + c.properties.map(function (p) { return p.name + \": \" + p.type + \";\"; }).join('\\n') + \"\\n      }\"; })\r\n            .join('\\n') + \"\\n  }\\n  \";\r\n    }\r\n    var normal = classes.filter(function (c) { return !c.global; });\r\n    text += \"export declare namespace \" + namespace + \"{\\n    \" + normal.map(function (c) { return classToString(c); }).join('\\n') + \"\\n  }\";\r\n    return Beautify.js(text, {});\r\n}\r\nexport function propertyToString(property) {\r\n    return ((property.readonly ? 'readonly' : '') + \" \" + (property.static ? 'static' : '') + \" \" + property.name + \": \" + property.type + \";\").trim();\r\n}\r\nexport function classToString(_class) {\r\n    return \"class \" + _class.name + (_class.extends ? \" extends \" + _class.extends : '') + \" {\\n    \" + (_class.constructorProperty\r\n        ? \"new \" + _class.constructorProperty.type.replace(/ \\=\\>.+/i, '') + \";\\n\"\r\n        : '') + _class.properties\r\n        .filter(function (p) { return p !== _class.constructorProperty; })\r\n        .map(function (p) { return propertyToString(p); })\r\n        .join('\\n\\n') + \"\\n  }\";\r\n}\r\n","dts":{"name":"/media/cyriac/0CC5166B0CC5166B/Work/es5-to-dts/src/generator.d.ts","writeByteOrderMark":false,"text":"import * as ts from 'typescript';\r\nexport interface File {\r\n    fileName: string;\r\n    content: string;\r\n    sourceFile?: ts.SourceFile;\r\n}\r\nexport declare function createProgram(files: File[], compilerOptions?: ts.CompilerOptions): ts.Program;\r\nexport interface Variable {\r\n    name: string;\r\n    type: string;\r\n}\r\nexport interface Property {\r\n    parentSymbol: string;\r\n    name: string;\r\n    type: string;\r\n    static?: boolean;\r\n    readonly?: boolean;\r\n}\r\nexport declare function collectProperties(program: ts.Program): Property[];\r\ninterface PseudoClass {\r\n    name: string;\r\n    constructorArgs: Variable[];\r\n    properties: Property[];\r\n    global?: boolean;\r\n    constructorProperty?: Property;\r\n    extends?: string;\r\n}\r\nexport declare function makePseudoClasses(program: ts.Program, properties: Property[]): PseudoClass[];\r\nexport declare function makeVariablesFromParameters(checker: ts.TypeChecker, params: ts.ParameterDeclaration[]): Variable[];\r\nexport declare function traverseProgram(program: ts.Program, callback: (node: ts.Node) => any): void;\r\nexport declare function getTypeString(checker: ts.TypeChecker, node: ts.Node): string;\r\nexport declare function makeDTS(classes: PseudoClass[], namespace: string): any;\r\nexport declare function propertyToString(property: Property): string;\r\nexport declare function classToString(_class: PseudoClass): string;\r\nexport {};\r\n"}}
